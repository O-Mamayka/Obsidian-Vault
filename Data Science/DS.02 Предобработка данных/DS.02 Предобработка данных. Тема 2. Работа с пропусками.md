## [DS.02 Предобработка данных. Тема 2. Работа с пропусками](https://practicum.yandex.ru/trainer/data-scientist/lesson/06fee637-dc9c-4733-bd5a-484b02a83672/)

**Источники трафика** - каналы, по которым посетители переходят на вебресурс
**Доля повторных покупателей** - метрика эффективности источника трафика интернетмагазина, отношение числа посетителей, совершивших****хотя бы две покупки, к числу посетителей,****совершивших хотя бы одну покупку****Система веб-аналитики
**система, которая автоматически собирает информацию** - со специальных счётчиков на сайте, фиксирующих поведение пользователей на сайте, и обрабатывает полученные результаты.
**Куки** - специальные текстовые файлы, которые остались в памяти устройства после первого посещения и при повторном визите отправляются на сервер.
**Логи** - текстовые файлы с информацией о посещениях сайта 
**Конверсия сайта** - метрика эффективности источника трафика, рассчитываемая по двум разным методикам:
- _Доля посетителей сайта_, совершивших целевые действия
- _Доля целевых_  действий на сайте
**User ID** - уникальный номер, присвоенный посетителю, чтобы отличить его от остальных
**NaN (англ. not a number)** - специальное значение типа float, которое используется если результат вычисления не может или не должен быть представлен как конкретное число, или попросту неизвестен
**None** - специальное значение нечислового типа NoneType, которое используется для обозначения отсутствия значения.
**Категориальная переменная** - переменная, которая принимает одно значение из ограниченного набора
**Количественная переменная** - переменная, которая принимает любое числовое значение из какого-то диапазона
**Логическая (булева) переменная** - переменная, указывающая на истинность или ложность какого-то события Словарь структура данных, которая хранит набор элементов в виде пары ключ-значение.

###  Урок 2. Конверсия и повторные

В широком смысле конверсия — это отношение целевого показателя к общему. Конверсия сайта показывает, какую долю от всех посетителей составляют целевые — те, кто что-нибудь купил или оставил заявку, то есть совершил _целевые действия_.

Обычно компании инвестируют в разные источники трафика, и руководители хотят знать, какой из них выгоднее. Аналитикам поручают посчитать соответствующие _метрики_ — показатели, отражающие эффективность действий в бизнесе. Источники трафика обычно сравнивают по _конверсии_.

Если зафиксировано 1000 посещений, или визитов, и в 50 из них была совершена покупка, конверсия составит `50 / 1000 * 100% = 5%`.

Ещё одна важная метрика — доля _повторных покупателей_. Если из 100 совершивших покупку 10 вернулись и снова что-нибудь купили, эта доля составит `10 / 100 * 100% = 10%`.

```python

email_visits = 1000 # количество визитов из рассылок
context_visits = 2500 # количество визитов из контекстной рекламы
email_purchases = 50 # количество покупок из рассылок
context_purchases = 100 # количество покупок из контекстной рекламы
email_conversion = email_purchases / email_visits# поделите email_purchases на email_visits
context_conversion = context_purchases / context_visits# напишите ваш код здесь
выведите значение конверсий рассылок

print('Конверсия рассылок: {:.0%}'.format(email_conversion))
выведите на экран значения конверсий контекстной рекламы
print('Конверсия контекстной рекламы: {:.0%}'.format(context_conversion))

if email_conversion > context_conversion:
    print('Вывод: рассылки эффективнее')
elif email_conversion == context_conversion:
    print('Конверсии равны, пора смотреть другие метрики')    
else:
    print('Вывод: контекстная реклама эффективнее')
```  

```python

import pandas as pd
purchases = pd.read_csv('/datasets/returned.csv')
purchases['total'] = purchases['first'] + purchases['repeated']
purchases['repeated_share'] = purchases['repeated'] / purchases['total']
print(purchases.sort_values(by='repeated_share', ascending=False))
```  

### Урок 3. User ID и куки

Чтобы различать посетителей сайта и запоминать их поведение, система веб-аналитики присваивает каждому свой номер, или уникальный идентификатор — user ID.

**Куки**. Когда пользователь заходит на сайт повторно, система «узнаёт» его и учитывает по user ID, присвоенному в первое посещение. Это происходит благодаря кукам — так называют короткие текстовые файлы, которые сайт передаёт браузеру, а браузер их сохраняет. Без кук аналитик не мог бы выполнить почти ни одну задачу. В том числе долю повторных покупателей.

Сайты обязаны уведомлять посетителей о том, что используют куки. В России — на основании закона 152-ФЗ «О персональных данных», а в Евросоюзе — Общего регламента по защите данных (General Data Protection Regulation)

```python

import pandas as pd

logs = pd.read_csv('/datasets/logs.csv')
# напишите код для подсчёта уникальных email здесь
#logs.info()
#email = logs.dropna(subset=['email']) 
email = len(logs['email'].unique())
print(f'Уникальных email: {email}')

# напишите код для подсчёта уникальных User ID здесь
#users = logs.dropna(subset=['user_id']) 
users = len(logs['user_id'].unique())
print(f'Уникальных User ID: {users}')
```  

### Урок 4. NaN и None

Значения `None`,  `NaN` указывают, что данных нет. `NaN` замещает отсутствующее в ячейке число и принадлежит к типу `float`, поэтому с ним можно проводить математические операции. `None` относят к нечисловому типу `NoneType`, и математические операции с ним неосуществимы.

Обнаружив строки с `None` и `NaN`, не поддавайтесь искушению немедленно их удалить. 

метод `value_counts()`, возвращает уникальные значения и количество их упоминаний, определим, сколько раз источник трафика был пропущен. value_counts(normalize=True)

* `normalize` (bool, по умолчанию False) — если `True`, то возвращаемый объект будет содержать значения относительно частоты встречаемых значений.
* `sort` (bool, по умолчанию True) — сортировка по частоте.
* `ascending` (bool, по умолчанию False) — сортировка по возрастанию.
* `bins` (int) — вместе подсчета значений группирует их по отрезкам, но это работает только с числовыми данными.
* dropna (bool, по умолчанию True) — не включать количество NaN.

```python
import pandas as pd

logs = pd.read_csv('logs.csv')

print(logs['source'].**value_counts****()**)

print(len(logs[logs['email'].isna()]))

print(logs[logs['email'].isna()].head())

logs = logs.fillna('example@example.com')
```

```python
print(hogwarts_points['points'].sum()) # `sum()` посчитаем, сколько всего баллов заработали ученики

print(hogwarts_points.groupby('faculty_name')['points'].sum()) # сколько очков у каждого факультета

print(hogwarts_points.groupby('faculty_name')['points'].sum().sum()) # складываем балы
```

Метод `groupby()` заменяет стандартные числовые индексы на значения столбца, по которому выполняется группировка, поэтому теперь индексы — это названия факультетов. Вызовем метод `idxmax()`, чтобы получить индекс элемента — то есть факультет — с наибольшим численным значением.

```python
print('Кубок получает', hogwarts_points.groupby('faculty_name')['points'].sum().idxmax())
```

#### Лабораторка.

```python

import pandas as pd
hogwarts_points = pd.read_csv('/datasets/hogwarts_points.csv')
hogwarts_points['faculty_name'] = hogwarts_points['faculty_name'].fillna(value='Гриффиндор')
student_points = hogwarts_points['points'].sum()
#сложите значения столбца 'points' этой группировки методом sum() и примените метод sum() к результату
faculty_sum = hogwarts_points.groupby('faculty_name')['points'].sum().sum()
name = hogwarts_points.groupby('faculty_name')['points'].sum().idxmax()
print(f'Сумма баллов учеников: {student_points}') # сумма значений столбца 'points'
print(f'Сумма баллов факультетов: {faculty_sum}') # сгруппируйте по столбцу 'faculty_name'
print(f'Кубок получает {name}')
```  

```python

import pandas as pd
logs = pd.read_csv('/datasets/logs.csv')
#logs.info()
#общее количество визитов из каждого источника
visits = logs.groupby('source')['user_id'].count()
print(visits)
purchase = logs.groupby('source')['purchase'].sum()
print(purchase)
conversion = purchase / visits
print(conversion)
```  

### Урок 5. Категориальные и количественные переменные

[https://practicum.yandex.ru/trainer/data-scientist/lesson/613ad6d5-57e9-4fbc-ada7-d6b47b4b3e51/](https://practicum.yandex.ru/trainer/data-scientist/lesson/613ad6d5-57e9-4fbc-ada7-d6b47b4b3e51/)

Способ работы с пропущенными значениями зависит от их типа. В датафрейме `pandas` могут содержаться категориальные или количественные данные:

* Категориальная переменная принимает одно значение из ограниченного набора.
* Количественная — любое числовое значение в диапазоне. Важное свойство количественных переменных — возможность сравнения и математические операции.

Категориальные и количественные переменные — это термины из статистики

Значения типа `int` могут быть и у количественных переменных, и у категориальных.

Логические значения или булевы — тип не из статистики, а из Python. Такие значения указывают на истинность или ложность какого-либо события и в Python обозначаются типом `bool`. Это тоже Категориальные значения.

! Индекс не относят к количественным переменным. Несмотря на то, что индексы принимают числовые значения, их нельзя сложить друг с другом или сравнить количественно.

Количественные переменные можно сложить или сравнить. Категориальные — нет. Верно определить тип переменной — первое дело в борьбе с пропусками.

### Урок 6. Индексация в атрибуте loc


Чтобы проводить глубокий анализ таблиц и заполнять пропуски, нужны условия с логическими выражениями. Разберем подробнее, как они работают в атрибуте `loc`.

#### Задача 1

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')

#print(data[data['Имя'] == 'Вася']['Роль']) # - выдодит DF "2 разработчик"

#print(data.loc[data.loc[:, 'Имя'] == 'Вася']['Роль']) # - выдодит DF "2 разработчик"

print(data.loc[2,'Роль']) # - выводит ЯЧЕЙКУ
```

#### Задача 2

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
data.loc[:, 'Новая функция'] = "+"

print(data)
```


Начнём с того, что вместо числовых индексов строк в атрибут `loc` можно передавать списки из значений `True` и `False`. 
```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = [False, True, False, False, False, False, False, False]

print(data.loc[rows])
```

#### Задача 3

```python

import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = data['Новая функция'] == '+'

print(rows)
```

* Запись `rows = data['Новая функция'] == '+'` содержит два равенства, но это не ошибка. Python понимает, что второе равенство — двойное, то есть логический оператор. Поэтому Python сначала выполняет логический оператор, а потом присваивает результат переменной `rows`. Мы как будто поставили скобки вот так: `rows = (data['Новая функция'] == '+')`. Точно так же будут работать и другие логические операторы, например `x = b > 5` или `y = a != 0`.
* Результат выполнения этого условия — уже не список `list`, как в прошлых примерах, а объект `Series`, потому что именно такой тип данных Pandas использует для хранения столбцов. Но это нам не помешает — атрибут `loc` понимает и то, и другое.

#### Задача 4

роль члена команды — разработчик. Сохраните результат этого выражения в переменную `rows` и напечатайте её на экране

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = (data['Роль'] == 'разработчик')

print(rows)
```

### # Задача 5

логическое выражение, проверяющее, что член команды не менеджер. Сохраните результат этого выражения в переменной `rows`

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')

rows = (data['Роль'] != 'менеджер')

print(rows)
```

#### Урок 7. Логические выражения в атрибуте loc

[https://practicum.yandex.ru/trainer/data-scientist/lesson/233e51d3-6c4c-423a-8047-825568389503/](https://practicum.yandex.ru/trainer/data-scientist/lesson/233e51d3-6c4c-423a-8047-825568389503/)

Подставим логическое выражение row в атрибут `loc`:

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = data['Новая функция'] == '+'

print(data.loc[rows])
```

#### Задача 1

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = data['Статья'] == '+'

print(data.loc[rows])
```

```python

# вариант с дополнительной переменной
rows = data['Новая функция'] == '+'
print(data.loc[rows])

# вариант без дополнительной переменной
print(data.loc[data['Новая функция'] == '+']) 
```

```python

import pandas as pd  
data = pd.read_csv('/datasets/projects.csv') 
print(data.loc[data['Новая функция'] == '+', 'Имя'])
```

**!!!** Обратите внимание: условие задаём на один столбец (`'Новая функция'`), а информацию получаем про другой столбец (`'Имя'`)
```python
import pandas as pd
data = pd.read_csv('/datasets/projects.csv')

#поменяем роль тем членам команды, которые участвуют в эксперименте
data.loc[data['Эксперимент'] == '+', 'Роль'] = 'экспериментатор'
print(data)
```

#### Задача 2

! Условие на строки выглядит так: `data['Эксперимент'] == '+'`
Извлеките из таблицы имена участников "эксперимента"

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = data['Эксперимент'] == '+'

print(data.loc[rows, 'Имя'])

#print(data.loc[data['Эксперимент'] == '+' , 'Имя'])
```

#### Задача 3

Заполним пропуски в столбце проекта с новой функцией

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
data.loc[data['Новая функция'] != '+', 'Новая функция'] = '-'

print(data)
```

Расширим возможности и научимся добавлять в условия логические операторы. Они работают как логические операторы `and`, `or`, `not` в обычной булевой логике Python, но есть различия:

* Операторы Pandas пишут не словами, а знаками: `and` превращается в `&` (амперсанд), `or` превращается в `|` (вертикальная черта), а `not` превращается в `~` (тильда).
* Каждое отдельное сравнение необходимо окружать скобками. Например, логическое выражение в Python `x > 0 and x < 10` в Pandas превратится в `(x > 0) & (x < 10)`.
* 
```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')

print(data.loc[(data['Новая функция'] == '+') & (data['Роль'] == 'разработчик')])
```

```python

import pandas as pd

data = pd.read_csv('/datasets/projects.csv')

rows = (data['Новая функция'] == '+') & (data['Роль'] == 'разработчик')
data.loc[rows, "Роль"] = "улучшатель"
print(data)
```

Найти всех членов команды, которые одновременно занимаются экспериментом и работают над статьей

```python
import pandas as pd

data = pd.read_csv('/datasets/projects.csv')
rows = (data['Эксперимент'] == '+') & (data['Статья'] == '+')

print(data.loc[rows])
```

```python

# Снимите всех разработчиков с проекта новой функции
import pandas as pd
data = pd.read_csv('/datasets/projects.csv')

rows = (data['Роль'] == 'разработчик') & (data['Новая функция'] == '+')
data.loc[rows, "Новая функция"] = "-"

print(data)
```

```python

# полная запись
print(data.loc[data['Новая функция'] == '+'])

# сокращённая запись
print(data[data['Новая функция'] == '+'])
```

**Сокращённая запись применима только:
* Если передаёте только условие (как в примере выше), то можно использовать любую из двух записей: они идентичны. Логические операторы тоже можно использовать.
* Если надо указать и условие, и столбец, подойдёт только полная запись с `loc`.
* Если хотите изменить значения в таблице, подойдёт только полная запись с `loc`.

#### Урок 8. Работа с пропусками в категориальных переменных


```python

import pandas as pd
game_survey = pd.read_csv('/datasets/game_of_thrones.csv') 
game_survey['family'] = game_survey['family'].fillna(value='') # пустая строка
```

Прежде всего, нужно ответить на вопрос, существует ли _закономерность_ в появлении пропусков.

Пропуски бывают трёх типов:

* **Полностью случайные**: если вероятность встретить пропуск не зависит ни от каких других значений.
* **Случайные:** если вероятность пропуска зависит от других значений в наборе данных, но не от значений собственного столбца.
* **Неслучайные:** если вероятность пропуска зависит от других значений, в том числе и от значений собственного столбца.

Иногда пропуски в категориальных столбцах могут принимать не стандартное значение `None` без определённого типа (`NoneType`), а значение типа `str`: например, `'None'`,  `'-'`, `'Null'`. В таких случаях метод `fillna()` не подойдёт — он работает только со значениями `NaN` или `None`. Для замены строковых значений вызывают атрибут `loc`, он осуществляет логическую индексацию — выбор значений по заданному условию. Логическая индексация позволяет найти в столбце значения `'None'` или другие значения типа `str` и заменить их.

![df.loc|640x400](https://pictures.s3.yandex.net/resources/2__3__1591108341.jpg)

```python

game_survey.loc[game_survey['gender'] == 'None', 'gender'] = 'женский'

# Количество покупок:

print(logs.groupby('source')['purchase'].count())

# Конверсия
logs = pd.read_csv('/datasets/logs.csv')

visits = logs.groupby('source')['purchase'].count()

purchase = logs.groupby('source')['purchase'].sum()

conversion = purchase / visits

print(conversion)
```

Количество действий для решения задачи можно сократить.

Вызовем метод **agg()**, указывающий, какие именно функции применить к столбцу _'purchase'._ Название столбца и сами функции запишем в особую структуру данных — **словарь**. Словарь состоит из **ключа** и **значения:**

Здесь ключ — это название столбца, к которому нужно применить функции, а значением выступает список с названиями функций.

![dict|640x400](https://pictures.s3.yandex.net/resources/Frame_3.2_1561106449.jpg)


```python

logs_grouped = logs.groupby('source').agg({'purchase': ['count', 'sum']})

logs_grouped['purchase']['sum']
```

#### Лабораторная работа


```python
import pandas as pd

logs = pd.read_csv('/datasets/logs.csv')
logs['email'] = logs['email'].fillna(value='') # ???????

# print(logs.head(5))
rows = (logs['source'] == 'None') & (logs['email'] == '')

print(logs.loc[rows]) # получили пустой DF, т.к. таких данных нет. вывод source = email

logs.loc[logs['source'] == 'None', 'source'] = 'email'

print(logs['source'].value_counts())
```

```python
import pandas as pd

logs = pd.read_csv('/datasets/logs.csv')

**logs['email'] = logs['email'].fillna(value='')**

# print(logs.head(5))

logs.loc[logs['source'] == 'None', 'source'] = 'email'

logs.loc[logs['source'] == 'undef', 'source'] = 'other' # заменим, т.к. доля не значительна, а конверсия очень близка

logs_grouped = logs.groupby('source').agg({'purchase': ['count', 'sum']})

logs_grouped['conversion'] = logs_grouped['purchase']['sum'] / logs_grouped['purchase']['count']

print(logs_grouped)
```

#### Урок 9. Работа с пропусками в количественных переменных
--------------------------------------------------------

* **user_id** — идентификатор пользователя
* **device_type** — тип устройства пользователя
* **age** — возраст пользователя
* **time** — время на сайте в секундах

Время и возраст — количественные переменные. Пропуски в таких переменных заполняют _характерными значениями_. Это значения, характеризующие состояние **выборки**, — набора данных, _выбранных_ для проведения исследования. Чтобы примерно оценить типичные значения выборки, годятся **среднее арифметическое** `mean()` или **медиана** `median()`. Методы применяют не ко всей таблице, к отдельному столбцу или к сгруппированным данным.

**Среднее арифметическое** — это сумма всех значений, поделённая на количество значений.

**Медиана** — это такое число в выборке, что ровно половина элементов больше него, а другая половина — меньше.

![median|640x480](https://pictures.s3.yandex.net/resources/Frame_3_1561652159.jpg)

Чтобы посчитать медиану списка значений, сначала упорядочим их по возрастанию

Среднее значение некорректно характеризует данные, когда некоторые значения сильно выделяются среди большинства.

print(f'Зарплата выросла на {new_director_mean / old_staff_mean - 1:.0%}')

#### Лабораторная работа


```python
import pandas as pd

metrica = pd.read_csv('/datasets/metrica_data.csv')

age_avg = metrica['age'].mean()

print(age_avg)

metrica['age'] = metrica['age'].fillna(32.48966336969903)

#metrica.info()

print(metrica.head(10))

#запишите среднее время просмотра

time_avg = metrica['time'].mean()

print(time_avg)

desktop_data = metrica.loc[metrica['device_type'] == 'desktop']

print(desktop_data.head())

desktop_data_time_avg = desktop_data['time'].mean()

print(desktop_data_time_avg)

mobile_data = metrica.loc[metrica['device_type'] == 'mobile']

print(mobile_data.head())

mobile_data_time_avg = mobile_data['time'].mean()

print(mobile_data_time_avg)
```


Чтобы ничего не забыть, скачайте [шпаргалку](https://code.s3.yandex.net/data-analyst/praktikum_data_analysis_takeaways_course2_theme1.pdf) и [конспект](https://code.s3.yandex.net/data-analyst/praktikum_data_analysis_abstract_course2_theme1.pdf) темы.

#### Где ещё почитать про обработку пропущенных значений
[Дополнительная информация про обработку пропусков в данных](https://basegroup.ru/community/articles/missing)
