# [Тема 05. Взаимосвязь данных](https://practicum.yandex.ru/trainer/data-scientist/lesson/c76efe6a-9f56-4b08-9109-da7cb52d9c14/)
**Диаграмма рассеяния (точечная диаграмма)** график, который каждый объект отображает как точку в заданных координатах 
**Коэффициент корреляции Пирсона** число от -1 до 1, которое показывает, как сильно будет изменяться одна величина при изменении другой
**Ячеечная диаграмма** - график, разделённый на ячейки, цвет которых отражает количество попавших в данную ячейку точек в заданных координатах

### Чему вы научитесь:
-   Строить диаграмму рассеяния;
-   Считать коэффициент корреляции Пирсона;
-   Находить совместное распределение для множества величин
-   Построить две матрицы диаграмм рассеяния: для исходных и отфильтрованных данных.

### Урок 2. Диаграмма рассеяния
График, где значения соединяются линиями, хорош, если иллюстрирует непрерывную связь. Например, на графике почасового изменения температуры уместно соединить точки замеров в 8 часов утра и в 9. А вот люди в наблюдениях никак не связаны друг с другом. Гораздо лучше обозначить отдельные сочетания роста и веса точками. Это возможно на особом типе графиков — scatter (пер. «разброс, рассеивание»). Передадим значение `scatter` параметру `kind` метода `plot()`:

```python
data.plot(x='column_x', y='column_y', kind='scatter')
```
На графике можно увидеть взаимосвязь между двумя величинами. А также понять, какие данные типичны, а какие - аномальны.

Взаимосвязь двух или нескольких величин называется «корреляция». График (да и жизненный опыт) позволяет утверждать, что рост и вес взаимосвязаны, или коррелируют. Очевидно не только наличие связи, но и прямая зависимость: чем больше рост, тем больше вес. В таком случае говорят, что корреляция положительная.


#### Урок 2. Задача
Постройте график по данным из `station_stat_full`, где для каждой АЗС будет отдельная точка: по горизонтальной оси — число заездов на АЗС, по вертикальной — медианное время заправки. Добавьте линии сетки.

```python
import pandas as pd

data = pd.read_csv('/datasets/visits.csv', sep='\t')

# фильтруем слишком быстрые и медленные заезды и АЗС
data['too_fast'] = data['time_spent'] < 60
data['too_slow'] = data['time_spent'] > 1000
too_fast_stat = data.pivot_table(index='id', values='too_fast')
good_ids = too_fast_stat.query('too_fast < 0.5')
good_data = data.query('id in @good_ids.index')
good_data = good_data.query('60 <= time_spent <= 1000')

# считаем данные по отдельным АЗС и по сетям
station_stat = data.pivot_table(index='id', values='time_spent', aggfunc='median')
good_stations_stat = good_data.pivot_table(index='id', values='time_spent', aggfunc='median')
stat = data.pivot_table(index='name', values='time_spent')
good_stat = good_data.pivot_table(index='name', values='time_spent', aggfunc='median')
stat['good_time_spent'] = good_stat['time_spent']

id_name = good_data.pivot_table(index='id', values='name', aggfunc=['first', 'count'])
id_name.columns = ['name', 'count']
station_stat_full = id_name.join(good_stations_stat)

station_stat_full.plot(x='count', y='time_spent', kind='scatter', grid=True)

```

### Урок 3. Корреляция

посередине — огромное количество точек, слившихся в единую массу. В облаке значений не разглядеть области более высокой плотности. Есть два способа сделать график нагляднее.

### Способ 1
Сделаем точки полупрозрачными, задав параметр `alpha`. Попробуем подобрать его оптимальное значение:

```python
hw.plot(x='height', y='weight', kind='scatter', alpha=0.015)
```

### Способ 2
Когда точек много и каждая в отдельности не интересна, данные отображают особым способом. График делят на ячейки; пересчитывают точки в каждой ячейке. Затем ячейки заливают цветом: чем больше точек — тем цвет гуще.
Такой тип графика задают через параметр `kind`, ему присваивают значение `hexbin` (от англ. hexagonal binning plot — «график, поделённый на шестиугольные области»).
Число ячеек по горизонтальной оси задают параметром `gridsize` (от англ. size of a grid — «размер сетки»), аналогом `bins` для `hist()`.
Параметр `sharex=False`. Если значение `True`, то пропадёт подпись оси Х, а без `sharex` график выйдет неказистым
```python
hw.plot(x='height', y='weight', kind='hexbin', gridsize=20, figsize=(8, 6), sharex=False, grid=True)
```

![hexbin|480x280](https://pictures.s3.yandex.net/resources/_14_1562657087.png)
Смысл этого графика, как и у гистограммы, — отображение частотности. Но на гистограмме показана только одна величина, а здесь две: нельзя сделать гистограмму одновременно и по росту, и по весу. Повышенная частота определённых сочетаний указывает на закономерность. Часто цель анализа данных в том и состоит, чтобы показать связь двух величин.

Взаимосвязь двух или нескольких величин называется ***«корреляция»***. График (да и жизненный опыт) позволяет утверждать, что рост и вес взаимосвязаны, или коррелируют. Очевидно не только наличие связи, но и прямая зависимость: чем больше рост, тем больше вес. В таком случае говорят, что корреляция положительная.
Оценить численно, насколько тесна взаимосвязь. Для этого находят коэффициент корреляции **Пирсона**. Он помогает определить наличие линейной связи между величинами и принимает значения от -1 до 1.
Чем ближе коэффициент корреляции Пирсона к крайним значениям 1 или -1, тем теснее линейная взаимосвязь. Если значение близко к нулю, значит, линейная связь слабая либо отсутствует вовсе. Бывает, что коэффициент нулевой не потому, что связи между значениями нет, а из-за того, что у неё более сложный, не линейный характер. Потому-то коэффициент корреляции такую связь не берёт.

Коэффициент Пирсона находят методом `corr()` (от англ. correlation — «корреляция»). Метод применяют к столбцу с первой величиной, а столбец со второй передают в параметре. Какая первая, а какая вторая — неважно:

```PYTHON
print(data['column_1'].corr(data['column_2']))
```

Справедливо ли обратное: увеличивается ли рост при наборе веса? Насколько нам известно из жизненного опыта, нет. Хотя корреляция иллюстрирует зависимость между величинами, она не доказывает наличие причинно-следственной связи. Нельзя сказать, что, прибавляя в весе, мы становимся выше. Итак, наличием корреляции причинно-следственную связь не доказать, но и не опровергнуть.

#### Урок 3. Задача
По данным из таблицы `station_stat_full` посчитайте коэффициент корреляции Пирсона между числом заездов на АЗС и временем заправки. Коэффициент выведите на экран.
```python
import pandas as pd

data = pd.read_csv('/datasets/visits.csv', sep='\t')

# фильтруем слишком быстрые и медленные заезды и АЗС
data['too_fast'] = data['time_spent'] < 60
data['too_slow'] = data['time_spent'] > 1000
too_fast_stat = data.pivot_table(index='id', values='too_fast')
good_ids = too_fast_stat.query('too_fast < 0.5')
good_data = data.query('id in @good_ids.index')
good_data = good_data.query('60 <= time_spent <= 1000')

# считаем данные по отдельным АЗС и по сетям
station_stat = data.pivot_table(index='id', values='time_spent', aggfunc='median')
good_stations_stat = good_data.pivot_table(index='id', values='time_spent', aggfunc='median')
stat = data.pivot_table(index='name', values='time_spent')
good_stat = good_data.pivot_table(index='name', values='time_spent', aggfunc='median')
stat['good_time_spent'] = good_stat['time_spent']

id_name = good_data.pivot_table(index='id', values='name', aggfunc=['first', 'count'])
id_name.columns = ['name', 'count']
station_stat_full = id_name.join(good_stations_stat)

print(station_stat_full['count'].corr(station_stat_full['time_spent']))
```

### Урок 4. Матрица диаграмм рассеяния
Жизненные явления гораздо сложнее и могут зависеть от множества факторов. Например, интересно изучить не только рост и вес, но и то, как на них влияют возраст и пол.
К сожалению, нарисовать понятный график сразу для четырёх параметров нельзя. Однако можно построить диаграммы раcсеяния попарно для роста и веса, роста и возраста, веса и пола, веса и возраста — всего 16 вариантов. В pandas такую задачу решают не `df.plot()`, а специальным методом: `pd.plotting.scatter_matrix(df)` (от англ. scatter matrix — «матрица рассеяния»).

```python
hwa = pd.read_csv('hwa.csv', sep=';')
pd.plotting.scatter_matrix(hwa, figsize=(9, 9))
```

![matrix|480x400](https://pictures.s3.yandex.net/resources/_15_1562657631.png)

Помимо попарных диаграмм рассеяния, можно получить попарный коэффициент корреляции для всех величин. Это можно сделать с помощью матрицы корреляции: 
```python
data.corr()
```

-   В верхней левой ячейке связь роста с ростом. Это не диаграмма рассеяния, а обычная гистограмма распределения по росту. Видно, что больше всего людей ростом 150–170 см.
-   В ячейке ниже: связь роста и веса. Можно выделить две зоны: узкую полоску до 150 см и широкую — после. Выходит, до 150 см рост и вес увеличиваются равномерно, а после — идут вразнобой.
-   Рост и возраст: до 150 см и 20 лет тесно связаны, затем зависимость перестаёт быть устойчивой. Дело в том, что в детстве и подростковом периоде мы растём примерно одинаково, а вот в 20 лет можем оказаться ростом и 150, и 180 см. Аналогично устроена связь «вес — возраст».
-   Из диаграммы разброса в нижней левой ячейке можно сделать вывод, что рослых мужчин в среднем больше, чем рослых женщин. Так же обстоит и с весом (соседняя ячейка male-weight).
-   Гистограмма пола `male` свидетельствует, что в выборке чуть больше женщин.
-   Гистограмма возраста `age` сообщает, что больше всего информации собрано о детях младше 5 лет и совсем мало данных о людях старше 75.
-   Гистограмма веса `weight` имеет два пика: правый характерен для веса взрослых, а левый иллюстрирует всплеск значений около 15–20 кг. Видимо, типичный вес дошкольника. Однако на гистограмме роста такого пика нет. Это может объясняться тем, что в возрасте пяти лет дети активно прибавляют в росте, но не в весе. Вот и получилась большая группа детей разного роста с весом около 20 кг: отсюда пик на гистограмме веса, без выдающихся соответствующих значений на гистограмме роста.
-   По другую сторону диагонали зеркально расположились те же данные, только оси поменялись местами. Часто проще воспринимать графики, по которым взгляд скользит слева направо. Так, на графике height-age в верхней строке (более наглядно, чем на графике age-height) видно, что люди старше 60 ниже ростом. Обратите внимание, из этой корреляции не следует факт, что после 60 рост уменьшается. Мы не наблюдали одних и тех же людей год за годом, так что можем лишь отметить, что в выборке пенсионеры ростом меньше остальных взрослых.
Такая таблица — матрица корреляции. Коэффициенты по диагонали всегда равны единице, ведь любая величина коррелирует сама с собой. Любопытно, что рост и вес во второй выборке имеют коэффициент корреляции 0.94, хотя в первом наборе данных корреляция была всего 0.52. Это очень большая разница, чем она обусловлена?

Вы изучили данные и знаете, что дело в возрасте: он влияет как на рост, так и на вес в начале жизни, потому-то они и связаны достаточно сильно. В таком случае говорят, что высокая корреляция объясняется третьим фактором. Проигнорируете влияние третьего фактора — неверно интерпретируете высокую корреляцию.

Напомним, что на значения последнего столбца смотреть бессмысленно, ведь биологический пол выражен категориальными значениями 1 и 0.

#### Урок 4. Задача
Создайте переменную `station_stat_multi`, где для каждой АЗС будет 3 числа:
1) среднее (не медиана) продолжительности заезда на АЗС; 2) средняя доля быстрых заездов; 3) средняя доля медленных заездов.
```python
import pandas as pd

data = pd.read_csv('/datasets/visits.csv', sep='\t')

# фильтруем слишком быстрые и медленные заезды и АЗС
data['too_fast'] = data['time_spent'] < 60
data['too_slow'] = data['time_spent'] > 1000
too_fast_stat = data.pivot_table(index='id', values='too_fast')
good_ids = too_fast_stat.query('too_fast < 0.5')
good_data = data.query('id in @good_ids.index')
good_data = good_data.query('60 <= time_spent <= 1000')

# считаем данные по отдельным АЗС и по сетям
station_stat = data.pivot_table(index='id', values='time_spent', aggfunc='median')
good_stations_stat = good_data.pivot_table(index='id', values='time_spent', aggfunc='median')
stat = data.pivot_table(index='name', values='time_spent')
good_stat = good_data.pivot_table(index='name', values='time_spent', aggfunc='median')
stat['good_time_spent'] = good_stat['time_spent']

id_name = good_data.pivot_table(index='id', values='name', aggfunc=['first', 'count'])
id_name.columns = ['name', 'count']
station_stat_full = id_name.join(good_stations_stat)

station_stat_multi = data.pivot_table(index = 'id', 
                                      #columns = ['time_spent', 'too_fast', 'too_slow'],
                                      values = ['time_spent', 'too_fast', 'too_slow'], 
                                      aggfunc = 'mean')

#print(station_stat_multi.head(3))

print(station_stat_multi.corr()) 

pd.plotting.scatter_matrix(station_stat_multi, figsize=(9, 9))

```

### Урок 5. Как выжать максимум из очевидности
Такие множественные графики и есть сама очевидность. В буквальном смысле. Дальше визуализировать некуда.
Самый большой коэффициент корреляции — 0,8 — между аномально долгими заправками (`too_slow`) и средней продолжительностью заправки (`time_spent`). Это заметно и на соответствующей диаграмме рассеяния. Зная одно значение, можно предсказать другое. Если бы слишком долгие заезды не были отрезаны, они бы сказались на среднем времени. Поэтому так важно было их отбросить и вместо среднего значения взять медиану.
Зависимость между аномально быстрыми заправками (`too_fast`) и средней продолжительностью заправки интереснее. На диаграмме рассеяния видно, что при `too_fast > 0.6` (т. е. более 60% заездов на АЗС продолжались меньше минуты) среднее время заправки почти полностью определяется как раз долей этих быстрых заездов. Если бы мы их не отфильтровали, типичное время заправки напоминало бы пит-стоп


#### Урок 5. Задача
Продемонстрируйте им два изображения: матрицу диаграмм рассеяния по исходным данным — и по отфильтрованным.
Добавьте в таблицу `station_stat_multi` столбец `good_time_spent` из данных `good_stations_stat`.
Распечатайте матрицу корреляции для `station_stat_multi`. Постройте диаграммы рассеяния попарно для всех величин методом `scatter_matrix`.
```python
import pandas as pd
data = pd.read_csv('/datasets/visits.csv', sep='\t')

# фильтруем слишком быстрые и медленные заезды и АЗС
data['too_fast'] = data['time_spent'] < 60
data['too_slow'] = data['time_spent'] > 1000
too_fast_stat = data.pivot_table(index='id', values='too_fast')
good_ids = too_fast_stat.query('too_fast < 0.5')
good_data = data.query('id in @good_ids.index')
good_data = good_data.query('60 <= time_spent <= 1000')

# считаем данные по отдельным АЗС и по сетям
station_stat = data.pivot_table(index='id', values='time_spent', aggfunc='median')
good_stations_stat = good_data.pivot_table(index='id', values='time_spent', aggfunc='median')
stat = data.pivot_table(index='name', values='time_spent')
good_stat = good_data.pivot_table(index='name', values='time_spent', aggfunc='median')
stat['good_time_spent'] = good_stat['time_spent']

id_name = good_data.pivot_table(index='id', values='name', aggfunc=['first', 'count'])
id_name.columns = ['name', 'count']
station_stat_full = id_name.join(good_stations_stat)

station_stat_multi = data.pivot_table(index='id', values=['time_spent', 'too_fast', 'too_slow'])
station_stat_multi['good_time_spent'] = good_stations_stat

print(station_stat_multi.corr()) 

pd.plotting.scatter_matrix(station_stat_multi, figsize=(9, 9))

```


Чтобы ничего не забыть, [скачайте шпаргалку](https://code.s3.yandex.net/data-analyst/conspects/praktikum_data_analysis_takeaways_course3_theme4.pdf) и [конспект темы](https://code.s3.yandex.net/data-analyst/conspects/praktikum_data_analysis_abstract_course3_theme4.pdf).
### Где ещё почитать про совместное распределение
[Диаграммы рассеяния (и другие графики)](https://habr.com/ru/company/ods/blog/323210/)  
[Визуализация данных](https://medium.com/nuances-of-programming/5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D1%85-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%BE%D0%B2-%D0%B2%D0%B8%D0%B7%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BD%D0%B0-python-%D1%81-%D0%BA%D0%BE%D0%B4%D0%BE%D0%BC-e0053808c83d)  
[Построение графиков в Python при помощи Matplotlib](https://python-scripts.com/matplotlib)  
[Иллюстрации про корреляцию](https://tocodata.com/marketing/korrelyaciya.html)