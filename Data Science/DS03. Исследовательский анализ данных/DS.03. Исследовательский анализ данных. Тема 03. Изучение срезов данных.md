# [Тема 03. Изучение срезов данных](https://practicum.yandex.ru/trainer/data-scientist/lesson/63c9f85c-0953-4338-a864-b1249e65bed3/)

**Срез данных** - часть данных из предоставленного набора, отобранная по определённым условиям
**Баг-репорт (сообщение об ошибке)** - сообщение, содержащее полную информацию об ошибке в программе, на сайте или в системе: суть ошибки и где, когда, при каких условиях она была обнаружена

В условиях допустимы арифметические операции. Найдём билеты, у которых дорога обратно `Travel_time_to` более чем в 1.5 раза быстрее, чем дорога туда `Travel_time_from`.

```python
df[1.5 * df['Travel_time_to'] < df['Travel_time_from']]
```

**!!!** Чтобы проверить наличие конкретных значений в столбце, вызовем метод **`isin()`**. Посмотрим, какие рейсы вылетают после 3 июля 2019:
```python

`df[df['Date_From'].isin(['04.07.2019', '05.07.2019'])] # находим элементы столбца Date_From, равные 4 или 5 июля`
```
Name|Описание|Синтаксис|Оператор 
   ---|---|---|---
**И**|Результат выполнения логической операции True, только если оба условия — True|(df['Is_Direct']) & (df['Price'] < 21000)|`&`
**ИЛИ**|Результат выполнения — True, если хотя бы одно из условий — True|(df['Has_luggage']) \| (df['Price'] < 20000)|\|
**НЕ**|Результат выполнения — True, если условие — False|~((df['Is_Direct']) \| (df['Has_luggage']))|`~`
Оператор `~` можно использовать и для проверки одного условия, например, чтобы отобрать билеты без багажа: `~(df['Has_luggage'])`. Обратите внимание, что здесь условия указывают в скобках — в отличие от синтаксиса логических операций Python с `or`, `and` или `not`.

```python
import pandas as pd

df = pd.DataFrame(
    {
        'From': [
            'Moscow',
            'Moscow',
            'St. Petersburg',
            'St. Petersburg',
            'St. Petersburg',
        ],
        'To': ['Rome', 'Rome', 'Rome', 'Barcelona', 'Barcelona'],
        'Is_Direct': [False, True, False, False, True],
        'Has_luggage': [True, False, False, True, False],
        'Price': [21032, 19250, 19301, 20168, 31425],
        'Date_From': [
            '01.07.19',
            '01.07.19',
            '04.07.2019',
            '03.07.2019',
            '05.07.2019',
        ],
        'Date_To': [
            '07.07.19',
            '07.07.19',
            '10.07.2019',
            '09.07.2019',
            '11.07.2019',
        ],
        'Airline': ['Belavia', 'S7', 'Finnair', 'Swiss', 'Rossiya'],
        'Travel_time_from': [995, 230, 605, 365, 255],
        'Travel_time_to': [350, 225, 720, 355, 250],
    }
)

print(df[df['Price'] < df['Price'].max() / 1.5]) # впишите нужное условие

print(df[(df['Travel_time_from'] >= 365) | (df['Travel_time_to'] < 250)]) 

rows = (df['Is_Direct'] != True) & (df['Date_To'] < '08.07.2019')

#print(rows)
print(df[rows]) # впишите нужное условие
```

### Урок 3. Срезы данных методом query()
[**Query()](https://practicum.yandex.ru/trainer/data-scientist/lesson/eb4924d9-7858-40ce-86cf-f2cc26f00c3f/)

Query - это гибкий инструмент получения срезов, и владеть им полезно. Однако существует и более простой способ — метод `query()` (пер. «запрос»).

```python
import pandas as pd

print(df.query('To == "Barcelona"'))
```
Обратите внимание, что значение `"Barcelona"` в коде задачи заключено в двойные кавычки. Это нужно, чтобы различать одинарные кавычки, оформляющие строку, и кавычки для элемента `Barcelona`.

```python
       From         To        Is_Direct   Has_luggage Price   Date_From  \
3  St. Petersburg  Barcelona      False         True  20168  03.07.2019   
4  St. Petersburg  Barcelona       True        False  31425  05.07.2019   

      Date_To  Airline  Travel_time_from  Travel_time_to  
3  09.07.2019    Swiss               365             355  
4  11.07.2019  Rossiya               255             250
```

Условия, указанные в параметре `query()`:

-   Поддерживают разные операции сравнения: `!=`, `>`, `>=`, `<`, `<=`.
-   Проверяют, входят ли конкретные значения в список, конструкцией: `Date_To in ["07.07.19", "09.07.2019"]`. Если нужно узнать, нет ли в списке определённых значений, пишут так: `Date_To not in ["07.07.19", "09.07.2019"]`.
-   Работают с логическими операторами в привычном виде, где «или» — `or` , «и» — `and`, «не» — `not`. 
**!!!**  Указывать условия в скобках необязательно. Без скобок операции выполняются в следующем порядке: сначала `not`, потом `and` и, наконец, `or`.

Условия для среза данных можно объединять.

```python
print(df.query('Is_Direct == True or Has_luggage == True'))

print(df.query('From == "Moscow" and (Is_Direct == True or Has_luggage == True)'))
```

### Урок 4. Возможности query()

Кроме объединения условий, в `query()` можно проводить математические операции. И даже вызывать методы.
**!!!**  допускают вызов методов к столбцам: column.mean()
```python
df.query('Travel_time_from < 2 * Travel_time_to ')

df.query('Travel_time_from < Travel_time_to.mean()')

#анолог фильтра:
rows = data['column1'] / 2 > data['column2'] + 0.5
```

Ещё в `query()` можно включать внешние переменные (не из датафрейма). Когда упоминаете такую переменную, помечайте её знаком `@`:

```python
maximum_price = 20000
`range`
```

#### Урок 4. Задача 1
Выберите строки, где: `Has_luggage` равно `False` и `Airline` не равно ни `S7`, ни `Rossiya`. Напечатайте полученную выборку на экране.

```python
print(df.query('Has_luggage == False and Airline not in ["S7", "Rossiya"]'))
```

#### Урок 4. Задача 2
Выберите строки, где `Airline` равно `Belavia`, `S7` или `Rossiya`, при этом `Travel_time_from` меньше переменной под названием `max_time`. Напечатайте полученную выборку на экране.

```python
print(df.query('Travel_time_from < @max_time and Airline in ["Belavia", "S7", "Rossiya"]'))
```


### Урок 5. Срезы в действии

```python
import matplotlib.pyplot as plt 

data.hist(bins=10) 
plt.show() 
data.hist(bins=100) 
plt.show()
```

#### Урок 5. Задача 1
Итак, нужно разобраться с аномалиями в выборке. Для начала найдите АЗС с самыми большими значениями в столбце `time_spent`.
Одной строкой кода отсортируйте таблицу по убыванию значений в столбце `time_spent` и выведите на экран первые 10 строк всей таблицы.

```python
import pandas as pd
data = pd.read_csv('/datasets/visits.csv', sep='\t')
print(data.sort_values(by='time_spent', ascending=False).head(10))
```

#### Урок 5. Задача 2
Сделайте срез `data` по АЗС с `id == "3c1e4c52"` и сохраните результат в переменную `sample`. Выведите на экран число заездов на эту АЗС.

```python
sample = data.query('id == "3c1e4c52"')
print(sample['id'].count())
```

#### Урок 5. Задача 3
Нужно сравнить распределение времени пребывания на станции `3c1e4c52` с распределением времени пребывания на всех АЗС. Если они сильно различаются, возможно, станция `3c1e4c52` представляет собой статистический выброс.

```python
data.hist('time_spent', bins=100, range=(0, 1500))
plt.show() 
sample.hist('time_spent', bins=100, range=(0, 1500))
plt.show() 
```


### Урок 7. Работа с датой и временем

В столбце `date_time` дата и время заезда. Из описания данных известно, что время заезда указали в часовом поясе UTC+0, в формате ISO. Значит, сначала слитно идут год, месяц, день; затем буквенный разделитель даты и времени T; затем часы, минуты и секунды — снова слитно.
При выводе значений формата `datetime` на экран Python автоматически разделяет их символами `-` и `:`, чтобы человеку было проще воспринимать данные.
Кроме этого необходимо:
-   округлять даты;
-   добывать отдельные компоненты из дат, например день недели;
-   «сдвигать» даты в другие часовые пояса.

О том, что операции предстоит выполнять именно с датами, аналитик сообщает pandas отдельно, через атрибут `dt` (от англ. date time). Атрибут `dt` указывает, что тип данных, к которым будут применены методы, — `datetime`. А значит, pandas не примет их за строки или числа.

Чтобы округлить время, применяют метод `dt.round()` (англ. round, «округлять»). В качестве параметра ему передают строку с шагом округления в часах, днях, минутах или секундах:
-   `D` — day (от англ. «день»);
-   `H` — hour (от англ. «час»);
-   `min` или `T` — minute (от англ. «минута»);
-   `S` — second (от англ. «секунда»).
```python
df = pd.DataFrame({'time': ['2011-03-01 17:34']})
df['time'] = pd.to_datetime(df['time'], format='%Y-%m-%d %H:%M')
df['time_rounded'] = df['time'].dt.round('1H') # округляем до ближайшего значения с шагом в один час
print(df['time_rounded']) 
```

Чтобы быть уверенными в том, что время будет округлено к большему значению, обращаются к методу `dt.ceil()` (от англ. ceiling — «потолок»). К меньшему значению, «вниз», округляют методом `dt.floor()` (англ. floor — «пол»).
```python
import pandas as pd

df = pd.DataFrame({'time': ['2011-03-01 17:15']})
df['time'] = pd.to_datetime(df['time'], format='%Y-%m-%d %H:%M')

df['ceil'] = df['time'].dt.ceil('1H') # округляем к потолку
df['floor'] = df['time'].dt.floor('1H') # округляем к полу
print('Время, округлённое вверх', df['ceil'])
print('Время, округлённое вниз', df['floor'])
```

Номер недели:
```python
df['weekday'] = df['time'].dt.weekday 
print(df['weekday'])
```

За временные сдвиги отвечает `pd.Timedelta()` (от англ. time delta — «дельта времени, перепад во времени»). Количество часов передают в параметре: `(hours=)`. Обратите внимание, что переход через 24 часа автоматически приводит к изменении даты, нам не нужно заниматься этой арифметикой.
```python
df['petropavlovsk-kamchatsky_time'] = df['moscow_time'] + pd.Timedelta(hours=9) 
print(df['petropavlovsk-kamchatsky_time'])
```
Поставить значение года на первое место
```python
pd.to_datetime(df['datetime'], yearfirst = True)
```

#### Урок 7. Задачи
Причиной коротких заездов может быть то, что водители нечаянно заезжают на АЗС, которые не работают по ночам. Если это действительно так, то вы увидите связь между короткими заездами и временем прибытия. Чтобы проверить эту гипотезу, изменим тип столбца `date_time` на более удобный тип для даты. Добавим местное время. Добавим столбец с округлённым до часа местным временем.

```python
import pandas as pd

data = pd.read_csv('/datasets/visits.csv', sep='\t')

data['date_time'] = pd.to_datetime(data['date_time'], format='%Y%m%dT%H%M%S')

data['local_time'] = data['date_time'] + pd.Timedelta(hours=3) 

data['date_hour'] =  data['local_time'].dt.round('1H')

print(data.head(5))
```


### Урок 8. Графики

За построение графиков в pandas отвечает метод `plot()` (пер. «график»).
Метод `plot()` строит графики по значениям столбцов из датафрейма. На оси абсцисс (x) расположились индексы, а на оси ординат (y) — значения столбцов.
Названия для графиков указывают строкой или переменной в параметре `title` (англ. «название»).
Добавим графику точности, передадим параметр `style`, со значением `o`, чтобы отметить значения таблицы точками.
Можно задать и другую форму точек. Например, `style='х'` пометит точки крестиками.
Когда нужен компромиссный вариант — и линии, и точки, — передают `style='o-'`.
 Если по горизонтальной оси отложены индексы и такой способ представления не годится для анализа, можно изменить сами индексы или передать методу `plot()` параметры осей. Так, оси абсцисс (x) присвоим значения столбца `b`, а оси ординат (y) — значения столбца `a`:

```python
df = pd.DataFrame({'a': [2, 3, 4, 5], 'b': [4, 9, 16, 25]}) 

print(df) 
df.plot()
df.plot(title='A и B')
df.plot(style='o') # 'o' похожа на кружок или точку, запомнить легко
df.plot(style='x') # 'x' - точь-в-точь крестик
df.plot(style='o-') # 'o-' - кружок и линия
df.plot(x='b', y='a', style='o-')
```
Pandas переименует горизонтальную ось: теперь она — `b`. А в легенде (списке условных обозначений на графике) осталась только линия со значениями столбца `a`.

Ещё не всё идеально: точки упираются в края графика. Скорректируем границы параметрами `xlim` и `ylim` — с ними вы познакомились, когда изучали ящик с усами. Напомним, что параметрам `xlim` и `ylim` в скобках передают минимальное и максимальное значение. Ограничим ось абсцисс значениями от 0 до 30.
Добавим линии сетки: с ними будет легче понять, какие именно значения отображены. Укажем параметр `grid` (пер. «сетка, решётка»), равный `True` (это значит, что отображать сетку — нужно).
Размером графика управляют через параметр `figsize` (от англ. size of a figure — «размер фигуры»). Ширину и высоту области построения в дюймах передают параметру в скобках: `figsize = (x_size, y_size)`. Сравним графики с разными размерами.
```python
# расширим границы
df.plot(x='b', y='a', style='o-', xlim=(0, 30)) 

# добавим сетку
df.plot(x='b', y='a', style='o-', xlim=(0, 30), grid=True) # добавим сетку

# строим большой график 
df.plot(x='b', y='a', style='o-', xlim=(0, 30), grid=True, figsize=(10, 3))
```

#### Урок 8. Задача
Пользуясь данными `sample`, постройте график зависимости продолжительности заправки от времени заезда. За основу возьмите соответствующие столбцы `time_spent` и `local_time`. Оси X присвойте значения столбца `local_time`, а оси Y — значения столбца `time_spent`.
Проверьте, всё ли верно отображено на графике: Каждый элемент обозначен точкой.  Диапазон оси Y указан от `0` до `1000`. Добавлены сетки. Размер графика 12х6 дюймов.

```python
import pandas as pd

data = pd.read_csv('/datasets/visits.csv', sep='\t')
data['date_time'] = pd.to_datetime(
    data['date_time'], format='%Y-%m-%dT%H:%M:%S'
)
data['local_time'] = data['date_time'] + pd.Timedelta(hours=3)

sample = data.query('id == "3c1e4c52"')
print(sample['id'].count())

sample.plot(x='local_time', y='time_spent', style='o', ylim=(0, 1000), grid=True, figsize=(12, 6))
```

### Урок 9. Группировка с pivot_table()

Прежде чем строить красивый график, позаботимся о красивом коде. В прошлом уроке вы сохранили срез в переменной `sample` и к ней применили метод `plot()`.
Entia non sunt multiplicanda praeter necessitatem — «Не следует множить сущности без необходимости». Фраза раскрывает принцип, названный **«Бритва Оккама»** в честь философа XIII века, монаха Уильяма из английской деревушки Оккам. Суть принципа: совершенство должно быть простым.
Например:
```python
data.plot(x='column1', # столбец значений для горизонтальной оси 
		  y='column2', # столбец значений для вертикальной оси 
		  style='o-', # стиль заполнения: 'o-'(точечно-линейный) 
		  xlim=(0, 30), # границы по оси X 
		  ylim=(30, 0), # границы по оси Y 
		  figsize=(4, 5), # размеры картинки: (x_size, y_size) 
		  grid=True) # отображать сетку или нет
```
Не будем множить сущности без необходимости и избавимся от промежуточных переменных. Применим метод `plot()` к результату работы `query()` без всяких `sample`

```python
(data
    .query('id == "3c1e4c52"')
    .plot(x='local_time', y='time_spent', 
          ylim=(0, 1000), style='o', grid=True, figsize=(12, 6))
)
# одна команда в несколько строк: не забыть заключить конструкцию в скобки
```

```python
data['date_time'] = pd.to_datetime(
    data['date_time'], format='%Y-%m-%dT%H:%M:%S'
)
data['local_time'] = data['date_time'] + pd.Timedelta(hours=3)
data['date_hour'] = data['local_time'].dt.round('1H')
(
    data.query('id == "3c1e4c52"')
    .pivot_table(index='date_hour', values='time_spent')
    .plot(grid=True, figsize=(12, 5))
)
```
На графике слишком много точек. Чтобы сделать его нагляднее, будем отмечать не визит, а среднюю продолжительность заправки в час. Вы уже создавали столбец `date_hour` с округлённым временем заезда на АЗС.
Обратимся к `pivot_table()`. Добавим сводную таблицу в цепочку между `query()` и `plot()`:
```python
data['date_time'] = pd.to_datetime(
    data['date_time'], format='%Y-%m-%dT%H:%M:%S'
)
data['local_time'] = data['date_time'] + pd.Timedelta(hours=3)
data['date_hour'] = data['local_time'].dt.round('1H')
(
    data.query('id == "3c1e4c52"')
    .pivot_table(index='date_hour', values='time_spent')
    .plot(grid=True, figsize=(12, 5))
)
```
Обратите внимание, что в среднем водители проводят на АЗС около 500 секунд. Помня о пике гистограммы в 200 секунд, нельзя не удивиться такому значению.
Есть и таинственный пик, когда среднее время заправки достигло 3000 секунд (почти час). Многовато. В прошлых уроках заезды дольше 1000 секунд вообще отбрасывались, ведь они не слишком похожи на правду. Добавим соответствующее условие в `query()`:
```python
(
    data.query('id == "3c1e4c52" and time_spent < 1000')
    .pivot_table(index='date_hour', values='time_spent')
    .plot(grid=True, figsize=(12, 5))
)
```
Средняя продолжительность заправки снизилась вполовину! Вот вы и увидели, как выбросы влияют на среднее.
Вычислим устойчивую к выбросам медиану. В `pivot_table()` значением параметра `aggfunc` передадим `median`.
Напомним, что в `aggfunc` передают функцию, которую применяют к значениям сводной таблицы. Например, метод `count` посчитает число значений в группе. Если в `aggfunc` не указать ничего, отработает расчёт среднего: `mean`.
```python
( data.query('id == "3c1e4c52"') .pivot_table(index='date_hour', values='time_spent', aggfunc='median') .plot(grid=True, figsize=(12, 5)) )
```

Обратите внимание, что даже без фильтра `time_spent < 1000` медиана дала среднюю продолжительность заправки примерно в 200 секунд. Медиана устойчива к выбросам, но всё же не безупречна: пик более 800 секунд в ночь со 2 на 3 апреля выглядит аномальным значением.
В целом нет никакой явной связи между продолжительностью заезда и временем дня. Это странно. На этой АЗС не бывает очередей? Или что-то не так с данными? Число заездов в течение дня точно должно меняться. Проверьте это.

#### Урок 9. Задача
1.  Сделайте срез из `data` по АЗС с `id=="3c1e4c52"`.
2.  Из данных этого среза постройте сводную таблицу, которая будет отображать количество заездов по времени прибытия. Передайте параметру `values` значение поля `time_spent`.
3.  Из данных этой таблицы постройте график зависимости между временем прибытия (ось X) и количеством заездов в час (ось Y). Добавьте линии сетки, задайте размер графика 12х5 дюймов.
```python
import pandas as pd
data = pd.read_csv('/datasets/visits.csv', sep='\t')
data['local_time'] = pd.to_datetime(
    data['date_time'], format='%Y-%m-%dT%H:%M:%S'
) + pd.Timedelta(hours=3)
data['date_hour'] = data['local_time'].dt.round('1H')
(
    data.query('id == "3c1e4c52"')
    .pivot_table(index='date_hour', values='time_spent', aggfunc='count')
    .plot(grid=True, figsize=(12, 5))
)
```

Наконец-то вы обнаружили ожидаемую закономерность! Ночью заездов на АЗС в несколько раз меньше, чем днём. Факт заезда в данных отображён правдоподобно. А вот с продолжительностью пока непонятно.

### Урок 10. Помечаем срез данных
Продолжительность заправки около 0 секунд всё ещё выглядит необъяснимо странной. Неужели такие заезды придётся отбросить? Это уже было сделано с подозрительно долгими заправками, признанными выбросами. Однако сверхкоротких заездов гораздо больше, чем очень долгих. Если от них избавиться, то данные наверняка сильно исказятся.
Как много строк потеряется, если просто отбросить подозрительно короткие события? Посчитаем долю заездов на АЗС продолжительностью менее 60 секунд
```python
# делим количество заездов короче 60 секунд на общее число заездов 
print(len(data.query('time_spent < 60')) / len(data))
```
Насколько равномерно они распределены по разным АЗС? Везде около 40%? Или где-то их нет, а на каких-то АЗС много? Выясните, откуда взялось такое среднее. Найдите для каждой АЗС среднее число аномально быстрых заездов. Пометьте их и сгруппируйте данные по АЗС. И по этим значениям уже постройте гистограмму.

#### Урок 10. Задача
Первым делом нужно создать переменную, чтобы выделить аномально быстрые заезды.
Добавьте в таблицу `data` столбец `too_fast` (пер. «слишком быстрый») со значениями: `True` - если продолжительность заезда из столбца `time_spent` менее 60 секунд. `False` - все остальные значения.
Рассчитать процент всех заездов короче 60 секунд можно разными способами. Можно посчитать значения `True` в столбце `too_fast` методом `value_counts()` и разделить получившееся число на количество строк.
Другой способ — применить к столбцу `too_fast` метод `mean()`. Ведь среднее рассчитывают так: сумму значений делят на количество значений. Если применить арифметическую операцию к булевым значениям `True` и `False`, значение `True` будет интерпретировано как 1, а `False` — как 0. С помощью `mean()` можно сделать оба вычисления сразу: посчитать `True` и разделить его на количество строк.
Таким образом, найти процент быстрых заездов можно с помощью среднего арифметического.
Переменная задана, процент посчитан, теперь можно группировать данные по АЗС. Для этого воспользуйтесь сводной таблицей.
Создайте переменную `too_fast_stat` и запишите в неё значения из сводной таблицы, сгруппировав доли быстрых заездов по АЗС.
Теперь вы знаете, сколько быстрых заездов на первых пяти АЗС в процентном отношении. 
Гораздо лучше визуализировать распределение быстрых заездов сразу по всем АЗС. Гистограмма, вот что нужно! Постройте гистограмму распределения значений в таблице `too_fast_stat` на 30 корзин.

```python
import pandas as pd

data = pd.read_csv('/datasets/visits.csv', sep='\t')
data['too_fast'] = data['time_spent'] < 60
too_fast_stat = data.pivot_table(index='id', values='too_fast')

too_fast_stat.hist('too_fast', bins=30)

data['too_slow'] = data['time_spent'] > 1000
too_slow_stat = data.pivot_table(index='id', values='too_slow')

too_slow_stat.hist('too_slow', bins=30)
```

Слишком долгих заправок гораздо меньше, чем слишком коротких. На большинстве станций длительных заездов меньше 5%. Простимся с ними без печали.

Следует сообщить, что вы видите проблему в том, что таких заправок слишком много. Сфокусируем их внимание на самой проблемной АЗС — там будет легче отловить ошибку. Или понять, что это не ошибка, а какое-то пока неведомое явление.
Правильное сообщение об ошибке, Конспект по теме «Изучение срезов данных» 6 или баг-репорт, должно чётко объяснять, в чём именно ошибка и как её найти. Коллеги, отвечающие за выгрузку, ничего о результатах нашего исследования не знают. Поэтому нужно чётко формулировать, где мы видим проблему.

```python
print(too_fast_stat.sort_values('too_fast', ascending=False).head())
data.query('id == "792b6ded"').describe()
```

Чтобы ничего не забыть, [скачайте шпаргалку](https://code.s3.yandex.net/data-analyst/conspects/praktikum_data_analysis_takeaways_course3_theme2.pdf) и [конспект темы](https://code.s3.yandex.net/data-analyst/conspects/praktikum_data_analysis_abstract_course3_theme2.pdf).

##### Где ещё почитать про срезы данных
[Индексы и срезы по индексам](https://devpractice.ru/pandas-indexing-part3/)  
[Индексация с использованием логических выражений](https://devpractice.ru/pandas-indexing-part3/#p6)

**PS**
метод `plot()` , который строит графики по значениям столбцов из датафрейма. На оси абсцисс (x) расположились индексы, а на оси ординат (y) — значения столбцов. Можно изменить индексы или передать методу `plot()` параметры осей.

`hist()` (Гистограмма) — это график, который показывает, как часто в наборе данных встречается то или иное значение. Гистограмма объединяет числовые значения по диапазонам, то есть считает частоту значений в пределах каждого интервала, подобно работе знакомого вам метода `value_counts()`. Она поможет оценить форму распределения и частоту каждого очка в наборе данных. Самое высокое значение на гистограмме — самое распространённое. Но для визуализации медианы или общего количества значений по категориям гистограмма не подойдёт.

`boxplot()` - диаграммы размаха. Метод `boxplot()` позволяет визуально оценить характеристики распределения, не прибегая к гистограмме. Удобно, когда нужно сравнить разные выборки.


### [Тест и выводы: ](https://practicum.yandex.ru/trainer/data-scientist/lesson/a11bf816-4f5c-46b5-8a18-617e6df58805/task/06fc263a-a06c-4f73-9e6f-b56c4e03871f/)

1. Срез данных в `pandas` можно получить: Правильный ответ
- Использовать список из `True` и `False` в качестве индекса, 
- Использовать значения, которые возвращает метод `isin()`, в качестве индекса
- Применить метод `query()`

4. Выберите все варианты кода, которые оставят только три последние строчки датафрейма.
```python
df[~df['number'].isin([4,5])]
df[df['number'].isin([1,2,3])]
```
8. Выберите код, который изменит тип значений в столбце `date` на `datetime` в формате `'11-03-07 17:15'`.
```python
pd.to_datetime(df['date'], format='%y-%m-%d %H:%M')
```

9. Почему можно заподозрить выбросы на таком графике?
- Несколько значений отделены от основной массы.

