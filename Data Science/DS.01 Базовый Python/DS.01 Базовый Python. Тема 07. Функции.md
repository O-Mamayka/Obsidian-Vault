## [DS.01 Базовый Python. Тема 07. Функции](https://practicum.yandex.ru/trainer/data-scientist/lesson/9d030872-6561-43bd-9569-43aff07e09da/)

**Функция** — это набор инструкций, которому дают уникальное имя. Когда функция вызвана, Python выполнит инструкции и вернёт результат.

* Код с функциями легче читать, поскольку связанные команды объединяют блок с общим именем — которое подсказывает назначение всех команд в блоке.
* Функции избавляют от повторов в коде: когда повторяющиеся команды объединены в функцию, достаточно вызвать функцию по имени, а не дублировать каждый раз сами команды.

**Функция** — именованный блок кода, к которому можно обратиться из другого места программы. Функция состоит из: **имени**; **параметров**, от которых зависит поведение функции; **тела**; **результата**, который функция возвращает.

Один из принципов совершенного кода — «не повторяться».

Без аргументов функция `print()` выведет на экран пустую строку. При вызове функция `print('текст')` аргумент `'текст'` меняет поведение функции `print()`: вместо пустой строки она выведет на экран сообщение. В таких случаях говорят, что функция `print()` получила на вход аргумент `'текст'`.

Четыре главные составляющие функции:

* имя, по которому функцию вызовут;
* параметры, которые меняют поведение функции;
* инструкции, которые исполнятся при вызове функции, ещё их называют телом функции;
* результат, который вернёт функция.

С функциями вы сталкивались ещё в школьной алгебре. Там можно найти те же элементы. Например, в функции `f(x) = x * 3`:

* `f` — имя;
* `x` — аргумент;
* `x * 3` — тело;

результат вычисления при подстановке значения `x`.

`f(2) = 2 * 3 = 6`

**Создание функции:**
```python
# заголовок функции с её именем и параметрами
def omelet(eggs_number):
# тело функции
	result = 'Омлет готов! Яиц в омлете: ' + str(eggs_number)
# последняя инструкция в теле возвращает результат_
	return result
```

* Всё начинается с заголовка функции. Через ключевое слово `def` задают имя функции, а в скобках — её параметры. Заголовок заканчивается двоеточием.
* Затем описывают тело функции. Каждая инструкция начинается с отступа в четыре пробела.
* Ключевое слово `return` указывает на значение, которое должна вернуть функция.

  

```python
def omelet(eggs_number):    
	result = 'Омлет готов! Яиц в омлете: ' + str(eggs_number)    
	return result  

omelet(2)
```
  

Два способа вывести результат работы функции на экран:

* Добавить `print(result)` в тело функции.
* Передать результат `omelet(2)` функции `print()`:

Cобственные функции помогают писать более простой и понятный код:

* устраняют повторы,
* задают структуру.

Один из принципов совершенного кода — «не повторяться». Когда в коде одинаковые инструкции встречаются несколько раз, их выносят в собственную функцию. Тогда вместо повтора целого блока инструкций достаточно только вызвать одну функцию:

### Смысловые блоки

Собственные функции разделяют смысловые блоки в коде. В тексте программы они играют ту же роль, что абзацы в обычном тексте.

Как именно делить текст на абзацы, а код на функции — вопрос вашего стиля. Специалисты решают его по-разному, руководствуясь общими принципами. Хорошим стилем считается разделение двух видов кода:

* Бизнес-логики — инструкции, которые имеют отношение к задаче бизнеса.
* Остальной код выполняет техническую функцию, «обслуживает» бизнес-логику.

### Параметры: значения по умолчанию

Присмотритесь, как знакомые функции работают с аргументами. Например, вы передавали функции `print()` аргументы, которые та выводила на экран. Но можно вызвать эту функцию с пустыми скобками — то есть без единого аргумента.

При объявлении функции можно задать для любого параметра значение по умолчанию, оператором `=`. Например, `eggs_number=2`. В таких случаях вокруг `=` не ставят пробелы

```python
# функция, возвращающая отфильтрованную копию таблицы
def filter_by_timing(data, target_duration=140): # target_duration — параметр со значением по умолчанию
    res = []
    for row in data:
        if row[4] > target_duration:
            res.append(row)
    return res # возвращаем отфильтрованную таблицу — накопленный список списков

# функция печати таблицы, принимает на вход список списков, ничего не возвращает (неявно возвращается None)
def print_movie_table(data):
    for movie in data:
        for elem in movie:
            print(f'{elem:<45}', end='')
        print()
```

### Задача 1. Функция возвращает данные о фильмах, которые вышли после года `year`.

```python

# функция печати таблицы, принимает на вход список списков, ничего не возвращает (неявно возвращается None)
def print_movie_table(data):
    for movie in data:
        for elem in movie:
            print(f'{elem:<45}', end='')
        print()

# определите функцию filter_by_year здесь
# функция, возвращающая отфильтрованную копию таблицы
def filter_by_year(data, year=1990): # 
    res = []
    for row in data:
        if row[2] > year:
            res.append(row)
    return res # возвращаем отфильтрованную таблицу — накопленный список списков

# название, страна, год, жанр, продолжительность (мин.), рейтинг "Кинопоиска" 
movies_table = [
    ['Побег из Шоушенка', 'США', 1994, 'драма', 142, 9.111],
    ['Крёстный отец', 'США', 1972, 'драма, криминал', 175, 8.730],
    ['Тёмный рыцарь', 'США', 2008, 'фантастика, боевик, триллер', 152, 8.499],
    ['Список Шиндлера', 'США', 1993, 'драма', 195, 8.818],
    ['Властелин колец: Возвращение Короля', 'Новая Зеландия', 2003, 'фэнтези, приключения, драма', 201, 8.625],
    ['Криминальное чтиво', 'США', 1994, 'триллер, комедия, криминал', 154, 8.619],
    ['Хороший, плохой, злой', 'Италия', 1966, 'вестерн', 178, 8.521],
    ['Бойцовский клуб', 'США', 1999, 'триллер, драма, криминал', 139, 8.644],
    ['Харакири', 'Япония', 1962, 'драма, боевик, история', 133, 8.106],
    ['Сталкер', 'СССР', 1979, 'фантастика, драма, детектив', 163, 8.083],
    ['Иди и смотри', 'СССР', 1985, 'драма, военный', 136, 8.094]
]

movies_table_filtered = filter_by_year(movies_table)
print_movie_table(movies_table_filtered)
```

### Задача 2

```python

# функция печати таблицы, принимает на вход список списков, ничего не возвращает (неявно возвращается None)
def print_movie_table(data):
    for movie in data:
        for elem in movie:
            print(f'{elem:<45}', end='')
        print()

# определите функцию filter_by_genre здесь
# функция, возвращающая отфильтрованную копию таблицы
def filter_by_genre(data, genre='драма'): # 
    res = []
    for row in data:
        if genre in row[3]:
            res.append(row)
    return res # возвращаем отфильтрованную таблицу — накопленный список списков

movies_table = [
    ['Побег из Шоушенка', 'США', 1994, 'драма', 142, 9.111],
    ['Крёстный отец', 'США', 1972, 'драма, криминал', 175, 8.730],
    ['Тёмный рыцарь', 'США', 2008, 'фантастика, боевик, триллер', 152, 8.499],
    ['Список Шиндлера', 'США', 1993, 'драма', 195, 8.818],
    ['Властелин колец: Возвращение Короля', 'Новая Зеландия', 2003, 'фэнтези, приключения, драма', 201, 8.625],
    ['Криминальное чтиво', 'США', 1994, 'триллер, комедия, криминал', 154, 8.619],
    ['Хороший, плохой, злой', 'Италия', 1966, 'вестерн', 178, 8.521],
    ['Бойцовский клуб', 'США', 1999, 'триллер, драма, криминал', 139, 8.644],
    ['Харакири', 'Япония', 1962, 'драма, боевик, история', 133, 8.106],
    ['Сталкер', 'СССР', 1979, 'фантастика, драма, детектив', 163, 8.083],
    ['Иди и смотри', 'СССР', 1985, 'драма, военный', 136, 8.094]
]

movies_table_filtered = filter_by_genre(movies_table)
print_movie_table(movies_table_filtered)
```
  

### Позиционные и именованные аргументы

Передать аргументы функции можно двумя способами. Покажем на примере функции из прошлого урока:

```python

# функция, возвращающая отфильтрованную копию таблицы
def filter_by_timing(data, target_duration): # у функции два параметра
    res = []
    for row in data:
        if row[4] > target_duration:
            res.append(row)
    return res # возвращаем отфильтрованную таблицу — накопленный список списков
```
  

```python

# Первый аргумент — список списков с данными, # второй — продолжительность фильма 
movies_table_filtered = filter_by_timing(movies_table, 170)
```
  

```python

# Передаём параметру data список списков movies_table, а параметру target_duration — значение 170 
movies_table_filtered = filter_by_timing(data=movies_table, target_duration=170)
```

Передавать именованные аргументы можно в любом порядке. Поведение функции от этого не изменится.
При вызове функции можно сочетать два вида аргументов.

```python
multiplication(2, second_number=1)
```

Смешанная запись бывает удобна, когда у функции есть обязательные параметры и множество необязательных.

**Преимущество** сочетания позиционных и именованных аргументов:

* позиционные аргументы позволяют лаконично задать обязательные параметры.
* через именованные аргументы удобно изменить значение по умолчанию любого из необязательных параметров.

**!!! Сначала позиционные аргументы, затем именованные**

**Результат Внутри и снаружи

Ключевое слово `return` возвращает значение локальной переменной при вызове функции. Так происходит в команде `print(omelet())`:

* она вызывает функцию,
* получает результат её работы,
* выводит результат на экран.

А вот команда `print(result)` не вызывает функцию и не получает её результат. Вместо этого она пытается напрямую обратиться к локальной переменной. Это приведёт к ошибке.

### Завершение работы функции

Ключевое слово `return` может встречаться в теле функции несколько раз. Но сработает только первая инструкция с `return`. Как только Python встречает это ключевое слово, он сразу завершает работу функции и возвращает значение.
```python
def number_to_month(num):

	if num == 1:
		return 'январь'

	elif num == 2:
		return 'февраль'

	elif num == 12:
		return 'декабрь'

    else:
        return 'такого месяца нет'
    print('Этот код никогда не выполнится!')

month = number_to_month(13)

print(month)
```

## Несколько результатов

```python
def find_square_and_perim(side1, side2):
    square = side1 * side2
    perimeter = 2 * (side1 + side2)
    return square, perimeter
print(find_square_and_perim(2, 3))
```

Здесь за ключевым словом `return` следуют две переменные — функция вернёт оба значения.

Технически функция всегда возвращает одно значение. Когда мы перечисляем несколько переменных после `return`, функция незаметно упаковывает их в единую структуру. А потом так же незаметно распаковывает — передавая внешним командам

```python

def find_square_and_perim(side1, side2):
    square = side1 * side2
    perimeter = 2 * (side1 + side2)
    return square, perimeter
square, perimeter = find_square_and_perim(7, 3)
print(f'Площадь прямоугольника равна {square}, периметр прямоугольника равен {perimeter}.')
```
  

### Частные случаи: функции с пустым и логическим результатом

Возвращение результата — необходимая составляющая функции. Но в функции может и не быть ключевого слова `return`. Такая функция вернёт `None` в качестве результата.

```python
def greeting():
    print('Пожалуйста, подождите немного....')
res = greeting()
print(res)
```

Другой частный случай — когда функции возвращают логические значения, `True` или `False`. Так, `is_age_appropriate` получает два аргумента:

* возраст,
* возрастное ограничение.

Если возраст больше, чем ограничение, функция вернёт `True`, иначе `False`.
Функции, которые возвращают `True` или `False`, называют предикатами.

```python

def is_age_appropriate_one(age, threshold): # передаём возраст и порог
    if age >= threshold: # если возраст больше или равен порогу, 
        return True # то возвращаем True
    return False # иначе возвращаем False
```

### Лаборка

**Задача 3**
```python
def get_hours_and_minutes(time_string):
	
	time = time_string.split(':')
	h = int(time[0]) # достаём нулевой элемент (часы) и приводит к целочисленному типу
	m = int(time[1]) # достаём первый элемент (минуты) и приводит к целочисленному типу
	return h, m # возвращаем через запятую два значения
	
time_str = '12:35'
hours, minutes = get_hours_and_minutes(time_str)
print(hours, minutes)
```

**Задача 4**
```python
def get_minutes_and_seconds(time_string):

	time_list = time_string.split(':')

	m = int(time_list[0])
	s = int(time_list[1])
	return m, s

def check_song_duration(time_string):
	m, s = get_minutes_and_seconds(time_string)
	return m * 60 + s < 210

print(check_song_duration('4:35'))
print(check_song_duration('2:10'))
```

Чтобы ничего не забыть, скачайте [шпаргалку темы](https://code.s3.yandex.net/data-analyst/praktikum_data_analysis_takeaways_basicPython_theme7.pdf).