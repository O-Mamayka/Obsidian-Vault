# [DS.01 Базовый Python. Тема 06. Условный оператор. Цикл while ](https://practicum.yandex.ru/learn/data-scientist/courses/f332f1ff-8036-4f31-ad9c-866410873a45/sprints/43469/topics/62258ebb-df00-4374-8194-0ea70c162fcd/lessons/298706c9-0a73-4103-ab51-da5f2f446ef1/)

**Логическое выражение** — утверждение, о котором можно сказать, истинно оно ( True ) или ложно ( False ).

**Операторы сравнения** — операторы == , != , > , &lt; , &gt;= , <= .

**Функция-предикат** — любая функция, которая возвращает True или False .

**Условный оператор** — оператор, входящий в конструкцию if..elif..else , с помощью которого можно реализовать ветвление. 6. Условный оператор. Цикл while 4

**Цикл while** — цикл с предусловием, который используют в тех случаях, когда точное количество повторений заранее неизвестно. Перед выполнением тела такого цикла каждый раз проверяется условие. Использование цикла while таит в себе опасность: программа может уйти в зацикливание, если результат проверки так и не станет False . Тогда тело цикла будет бесконечно выполняться.


**Булев** тип данных показывает, например: Было ли утверждение истинным, либо ложным: фильм или был награждён — третьего не дано. Для работы с такой информацией в Python существует особый тип данных — **_логический (bool)_**. Его ещё называют булевым в честь математика XIX века Джорджа Буля.

Булевы значения уместны везде, где на вопрос можно ответить «да» или «нет». Применяют в разных сферах: **Чат-боты.** **Беспилотные автомобили.** **Интернет-магазины..**

Вопросы в Python формулируют в виде утверждений, а булевы значения хранят информацию об их истинности: `True` / `False`;

Логики заметили, что не все фразы из повседневной речи можно назвать истинными или ложными. Например, такая оценка неприменима:

* к вопросам — например, «который час?»;
* приказам — «Стой!»;
* просьбам — «Пожалуйста, сдайте проект вовремя».

Повествовательные предложения, которые всё же могут быть либо истинными, либо ложными, логики назвали высказываниями.

Так и в Python есть несколько типов выражений, которые возвращают `True` или `False`, истину или ложь. Их называют логическими выражениями:

* выражения с операторами сравнения: `== , !=, >, <, >=, <=`;
* с логическими операторами: `and`, `or`, `not`;
* функции-предикаты.

Функции-предикаты — любые функции, которые возвращают `True` или `False`. Таковы, например, методы строк, которые проверяют символы в строке:

* `islower()` — возвращает `True`, если в строке нет прописных букв;
* `isdigit()` — возвращает `True`, если строка состоит только из числовых знаков;
* `isalpha()` — возвращает `True`, если в строке только буквы, без пробелов и знаков препинания.

## Условный оператор - `if..elif..else`. 
**[link](https://practicum.yandex.ru/learn/data-scientist/courses/f332f1ff-8036-4f31-ad9c-866410873a45/sprints/43469/topics/62258ebb-df00-4374-8194-0ea70c162fcd/lessons/e05334eb-c929-4043-8a2c-50d6c86d752a/)

Некоторые алгоритмы, в зависимости от данных Python могут выполнять одни инструкции, а другие — пропускать. В коде появятся независимые «ветки» — в зависимости от соответствия определённому условию будут выполняться разные части кода.

### Элементы if
* **Ключевое слово** `**if**`**.** В переводе с английского «если». Как и этот союз, `if` предшествует самому условию;
* **Утверждение.** Это само условие, то есть проверка на истинность определённого утверждения. Для проверки используются операторы сравнения: `==`, `!=`, `>=` и другие;
* **Двоеточие и отступ в четыре пробела.** Здесь как в циклах — без этих двух элементов ничего не сработает;
* **Действие.** Что сделает программа, если утверждение окажется истиной, — то есть оператор сравнения вернёт `True`.

В полной записи к конструкции добавляются ещё два блока:

* **Ключевое слово** `**else**`**.** В переводе с английского «иначе». Предшествует блоку программы, который будет выполнен в ином случае. После `else` тоже ставится двоеточие;
* **Альтернативное действие.** Что сделает программа, если условное утверждение окажется ложным, то есть оператор сравнения вернёт `False`. Этот блок также начинают отступом в четыре пробела.

```Python
weather = 'солнце'
if weather == 'дождь':
# первая ветка кода
    print('взять зонт')
else:
# вторая ветка кода
    print('помыть машину')
```

Ключевое слово `elif` **добавляет ветки** в условную конструкцию. Таких веток может быть любое количество.
```python
for year in years: # для каждого года в списке выполняется проверка

	if 1960 <= year <= 1969: # если год находится между 1960 и 1969 (включая 1960 и 1969),

		print('Фильм вышел в шестидесятые.') # то выводится это сообщение

	elif 1970 <= year <= 1979: # иначе, если год находится между 1970 и 1979 (включая 1970 и 1979),

		print('Фильм вышел в семидесятые.') # то выводится это сообщение

	else: # иначе, если ни одно из условий выше не выполнилось,

		print('Эпоха не определена') # то выводится это сообщение
```

### **Фильтр для таблицы**

```python
for movie in movies_table: # проходим по всем строкам исходной таблицы
    if movie[4] > 180: # если длительность фильма из очередной строки больше 180, 
        movies_filtered.append(movie) #добавляем в список movies_filtered строку

print(movie)
```

Фильтр для списка списков состоит из трёх частей:

* Переменная с результатом — пустой список, в который мы сохраним подходящие строки таблицы.
* Цикл проходит по исходному списку списков и для каждого подсписка запускает условный оператор `if`.
* Условная конструкция с `if`. Если подсписок соответствует условию, инструкция сохранит его в переменную с результатом.

  
### Сложные логические выражения

```python
number = 5
if number < 7 and number > 4 and number != 6:
    print('число соответствует трём условиям: оно меньше семи, больше четырёх и не равно шести')
```

| Выражение A | Выражение B | A and B | A or B | not A |
| --- | --- | --- | --- | --- |
| True | True | True | True | False |
| True | False | False | True | False |
| False | True | False | True | True |
| False | False | False | False | True |

### Счётчики
```python
drama_count = 0 # счётчик для количества драм, вначале присваиваем ему 0

for movie in movies_table: # для каждого фильма

if 'драма' in movie[3]: # пользуетесь операцией in: проверяете наличие подстроки 'драма'

drama_count += 1 # если нужная подстрока присутствует, то добавляете к счётчику единицу
```

**Обработка результата подсчёта**

В Python специальный оператор возвращает остаток деления — `%.`Целочисленное деление в `python` выполняет оператор `//.`

Plain Text
```python
hours = action_timing_total // 60
minutes = action_timing_total % 60
print(f'Общая продолжительность боевиков составляет {hours} часа {minutes} минут.') 
# воспользуемся f-строками для красивого и удобного вывода
```
  
## Цикл while
**[link](https://practicum.yandex.ru/learn/data-scientist/courses/f332f1ff-8036-4f31-ad9c-866410873a45/sprints/43469/topics/62258ebb-df00-4374-8194-0ea70c162fcd/lessons/218152e7-2269-4458-afa1-fbb08b7d2dcf/)

* Когда пользователь вводит текст в форму, цикл может обрабатывать эти данные прямо во время ввода. Такой цикл не должен останавливаться, пока пользователь не закончит ввод.
* Если веб-камера реагирует на движение, цикл может пересылать данные, пока движение не прекратится.

В цикле `while` перед очередным шагом происходит проверка условия. Если это условие оказывается истинным — выполняются инструкции из тела цикла. Цикл остановится, когда логическое выражение в условии вернёт `False`.

```python
from random import randint

capacity = 400 # грузоподъёмность лифта
total_weight = 0 # переменная для суммарного веса

while total_weight < capacity: # пока суммарный вес меньше грузоподъёмности лифта
    person_weight = randint(30, 120) # генерируется случайное целое число от 30 до 120
    total_weight += person_weight # сгенерированный вес добавляется к суммарному весу

print(f'А всё уже, всё уже! Лифт заполнен! Раньше надо было! Загруженность: {total_weight}')
```
  

### Бесконечные циклы

!!! Использование цикла `while` таит в себе опасность: программа может уйти в зацикливание, если результат проверки так и не станет `False`. Тогда тело цикла будет выполняться **бесконечно**.

### Цикл и счётчики

Цикл `while` может заменить `for` при создании счётчика — если нужно посчитать первые N элементов списка, удовлетворяющих условию.
  
```python
count = 0 # количество найденных фильмов, снятых в США

while count < 3: # пока значение счётчика меньше трёх

if movies_table[current][1] == 'США': # проверка первого элемента текущего списка с индексом current (страна производства текущего фильма)

filtered_movies.append(movies_table[current]) # если страна — США, то список добавляется в filtered_movies

count += 1 # а значение найденных фильмов из США увеличивается на один

current += 1 # вне зависимости от страны индекс текущего списка увеличивается на один на каждом шаге цикла
```
  

Чтобы ничего не забыть, скачайте [шпаргалку темы](https://code.s3.yandex.net/data-analyst/praktikum_data_analysis_takeaways_basicPython_theme6.pdf).